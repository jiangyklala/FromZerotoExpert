# FromZerotoExpert

## 注册:
### 用户名限制
+ 不能为空(前端)
+ 不能有空格
+ 不能有敏感词
+ 用户名唯一
### 密码限制
+ 不能为空(前端)
+ 长度
+ 强度(只能用三种字符中至少两种)
### 加密密码
+ 随机盐 + 真盐 + 双重MD5
## 登录
### 用户名限制
+ 不能为空(前端)
+ 是否不存在
    + 不符合"注册"时的限制
    + 未注册
### 密码限制
+ 不能为空(前端)
+ 错误
    + 不符合"注册"时的限制
    + 密码错误
### 自动登录
  1. **首次登录:** 登录时生成Cookie: fzteUser-userAccount, 同时在 redis 中以hash存储用户信息: key: userAccount 暂无 field 和 value；在我的实现中用户登录成功后先添加唯一登录凭证，这个凭证为 key:userAccount field:lc value:xxx, 所以到添加用户登录凭证时，在redis中一定存在这个账号的信息。而我的用户登录凭证只是需要redis中存在这个key = userAccount，所以此时只需更新其有效期即可。
  2. **二次登录:** 登录时检测Cookie,
     + 若有, Cookie的值即为上次登录的账号，若这次登录的账号和上次相同则更新 Cooike 和 redis 中的键有效期；若不相同，创建新账号的信息（此时不能删除旧账号的信息：若此时旧账号在其他地方登录，那它的信息莫名其妙的就没了，要重新登陆。
     + 如无, 进行1.
  3. **访问首页:** 根据是否有Cookie, 且 Cookie 中的 userAccount 在 redis 中是否过期(防止用户手动更改 Cookie 有效期)实现自动登录
### 不允许多个设备同时在线
将用户登录时的时间戳作为唯一登录凭证，一份作为 Cookie 【loginCert = 时间戳】放在用户的浏览器中，一份记录在redis中：【lc = 时间戳 】（loginCertifate）。

每次用户登录时都会更新这个唯一登录凭证，拦截器中拦截本地的登录凭证和 redis 记录的凭证不同的请求。如果同时有两用户登录，则后面用户的唯一登录凭证是最新的，前一个人只需在下一次操作时用拦截器中拦截即可。

**遇到的问题：**

+ 两个设备都需要在**本地**有一个：能通过其访问到该用户在redis中的信息的变量，于是就把这个变量从原来的雪花ID换成了用户登录的【账号】（当前我的程序还没有区分账号和昵称，后续慢慢改）
  + 已区分

+ 在创建拦截器时，因为拦截器是在Spring Context 初始化之前执行，不能直接注入 Service 对象，但我的拦截判断需要它。虽然通过一些途径能达到我的需求，但这样是不是”走歪路“？

+ 在拦截器判断中我需要用到保存的Cookie，就会导致每次用户在请求时都需要重新查一遍所有Cookie直至找到我要用的Cookie，效率不高？

+ 有些地方的代码我自己都看着臃肿：
  + 后端查找 Cookie 的三种方式


### 允许 PC 和移动端同时在线
需要用到 request 中 key 为 user-agent 的值。思路：扩展”唯一登录用户凭证“，根据当前登录的电脑/手机设备，生成“唯一设备登录凭证”，在本地设置名为 ”PcLoginCert" 或 “MbLoginCert” 的 Cookie，同时也在 redis 用户哈希表中用 “plc” 或 “mlc” 保存对应凭证。拦截器拦截时，根据当前电脑/手机，检测 redis 中相应的凭证是否一致。

### 如何记录用户的在线状态和离线状态？

**想法1：** 用户登录时在redis中记录 online=1，用户登出时设置 online=0 。

问题1：如何准确记录用户的登出状态？

+ js中的 onbeforeunload, onunload 不能完全满足需求，`As of Chrome 60, the confirmation will be skipped if the user has not performed a gesture in the frame or page since it was loaded.`  即用户登录后必须在网页中做一些操作，否则不会执行那两个函数

**想法2：** 在用户端向服务器端发送“心跳信息“。

问题1：会导致服务器增加负载

### 统计网站在线人数

1. **我的思路是：** ”心跳信息“ + redis中的 zset (长轮询）；

   + 用户登录网站后每隔一段时间向服务器发送一条”心跳信息“：在 redis 中的有序集合中设置 key = oL(onLine)，score = 发送心跳信息时的时间戳，member = 账号。
   + 网站每隔一段时间访问 /ShowOnlineUsers 接口：在 zset 中查找出 score 在[当前时间戳 - 3秒]到[当前时间戳]的 member，转为 JSON 数组返回到前端显示

   **中间遇到了点困难：** 由于我原先的程序只在 UserService 中设置了一个 jedis 静态成员来访问 redis，哪怕只有一个用户登录时：若某一时刻（发送心跳信息的时间与显示在线人数时间的最小公倍数）就会造成 jedis 访问出问题，这是我第一次实践中遇到并发问题。解决方法是改用 jedis连接池，每次用到 jedis 时从池中获取一个 jedis 实例，用完归还就彳亍。

2. 优点：实现简单
   缺点：用户频繁发出心跳信息会对服务器带来压力，而“当前在线人数显示”可以设置为一个按钮，用户点击时才显示，减轻服务器压力

3. 我在想是否有一种方法，可以在用户登录网站时在redis中当前用户哈希表中添加 ”online“ = ”1“，用户登出时再将其设置为”0“，这是对服务器最友好的方法；但难点在于如何准确的判断用户登出了网站，我目前找到最有希望的方法是在前端使用 window.onbeforeunload, 但是它必须要用户在网站上做一定的操作后才能生效，如果你刚登录就立马关闭网站窗口，这个 onbeforeunload 就无法执行，此时 ”online“ 字段一直就是“1”。

4. 我还找到了一种方法：使用 WebSocket 实现服务器和客户端的全双工通信，缺点是部分浏览器不支持（可以在不支持时用长轮询），目前正在实现中。

5. 10.13 使用 setTimeout 的延时递归来代替 setInterval：setInterval会产生回调堆积，特别是时间很短的时候。  

### 统计网站每日访问IP，PV，UV

**IP:** 通过 HttpServeletRequest 获取；redis中存：fU:ip:当前日期 = ip；使用 HyperLogLog

**PV:** 用户每次刷新网页 + 1； redis中存：fU:pv:当前日期 = 0; 使用 字符串

**UV：** 通过用户浏览器中的 Cookie：【fzteUser = 用户账号】来确认一个访客；redis中存：fU:uv:当前日期 = 用户账号；使用 HyperLogLog

**如何将这些数据保存起来？** 

--> 就存在redis中，设置有效期为 30 天 （存在redis中资源占用）

--> 定时任务：每日0点以后将 redis 中的这些数据转移到 mysql 中，同时 mysql 删除30天以前的数据：使用了 Spring 的定时任务功能：具体见 /timer/IPUVPVTransfer





